#include <SFML/Graphics.hpp>
#include "grid.h"
#include "game.h"
#include "computer.h"
#include "formationWin.h"
#include "starting.h"
#include "loadingScreen.h"
#include "leaderBoard.h"


using namespace sf;

// Constants and global variables

////////////////////////// For display //////////////////////////
const int grid_size = 10;
int p1_x_offset = 80;
int p1_y_offset = 80;
int p2_x_offset = 960;
int p2_y_offset = 80;
const int window_width = 1920;
const int window_height = 1080;
const int cell_width = 80;
string player1Name = "";
string player2Name = "";
string gameMode = "player_vs_computer";


/////////////////////////// initializations ///////////////////////

// Player 1 grid
char player1Grid[10][10] = 
{
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'}
};

// Player 2 grid
char player2Grid[10][10] = 
{
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'}
};

/*Ship is a struct that contains properties of ships
and the information of row and column of the ship
that will be loaded from file or generated by computer*/
Ship p_1_aircraftCarrier;
Ship p_1_battleship;
Ship p_1_cruiser;
Ship p_1_destroyer;
Ship p_1_submarine;
Ship p_2_aircraftCarrier;
Ship p_2_battleship;
Ship p_2_cruiser;
Ship p_2_destroyer;
Ship p_2_submarine;


int main()
{

    // setting the spaces for the ships to track their health
    p_1_aircraftCarrier.spaces = p_2_aircraftCarrier.spaces = 5;
    p_1_battleship.spaces = p_2_battleship.spaces = 4;
    p_1_cruiser.spaces = p_2_cruiser.spaces = 3;
    p_1_destroyer.spaces = p_2_destroyer.spaces = 2;
    p_1_submarine.spaces = p_2_submarine.spaces = 3;

    
    sf::RenderWindow w(sf::VideoMode(window_width, window_height), "2Grid");
    
    SoundBuffer click,shoot,splash,explosion, clickEffect;
	clickEffect.loadFromFile("sound/Button_click.wav");
    click.loadFromFile("sound/click.wav");
    shoot.loadFromFile("sound/shoot.mp3");
    splash.loadFromFile("sound/splash.mp3");
    explosion.loadFromFile("sound/explosion.mp3");

    Sound click_sound, shoot_sound, splash_sound, explosion_sound, clickEffect_sound;
    click_sound.setBuffer(click);
    shoot_sound.setBuffer(shoot);
    splash_sound.setBuffer(splash);
    explosion_sound.setBuffer(explosion);
    clickEffect_sound.setBuffer(clickEffect);


    Music music;
    music.openFromFile("sound/music.mp3");
    music.setLoop(true);
    music.play();


    // Display the starting window to select mode and enter names
    startingScreen(w, gameMode, player1Name, player2Name, clickEffect_sound);

    // Display the formation window to place the ships
    formationWindow(player1Grid, w, p_1_aircraftCarrier, p_1_battleship, p_1_cruiser, p_1_destroyer, p_1_submarine);

    
    if (gameMode == "player_vs_player")
    {
        // if the game mode is player vs player, display the formation window for player 2
        formationWindow(player2Grid, w, p_2_aircraftCarrier, p_2_battleship, p_2_cruiser, p_2_destroyer, p_2_submarine);
    }
    else
    {
        //else if the game mode is player vs computer, generate the computer grid randomly
        generateComputerGridRandomly(p_2_aircraftCarrier, p_2_battleship, p_2_cruiser, p_2_destroyer, p_2_submarine, player2Grid);
    }
    
    //  loading page
    music.setVolume(10);
    loadingPage(w);
    music.setVolume(50);
    //health and moves of the players
    int player2Health = p_2_aircraftCarrier.spaces + p_2_battleship.spaces + p_2_cruiser.spaces + p_2_destroyer.spaces + p_2_submarine.spaces;
    int player1Health = p_1_aircraftCarrier.spaces + p_1_battleship.spaces + p_1_cruiser.spaces + p_1_destroyer.spaces + p_1_submarine.spaces;
    int player1Moves = 100;
    int player2Moves = 100;


//////////////////////// SFML texture and sprites /////////////////////////////////////////////////
    // adding background
    sf::Texture backgroundTexture;
    backgroundTexture.loadFromFile("images/background.png");
    sf::Sprite background(backgroundTexture);
    background.setScale(3.3334, 3.3334);

    //  declaring the textures for the ships
    sf::Texture aircraftCarrierTexture;
    sf::Texture battleshipTexture;
    sf::Texture cruiserTexture;
    sf::Texture destroyerTexture;
    sf::Texture submarineTexture;

    // load the textures for the ships
    if (!aircraftCarrierTexture.loadFromFile("images/A.png"))
    {
        std::cout << "Error loading aircraft carrier texture\n";
    }
    if (!battleshipTexture.loadFromFile("images/B.png"))
    {
        std::cout << "Error loading battleship texture\n";
    }
    if (!cruiserTexture.loadFromFile("images/C.png"))
    {
        std::cout << "Error loading cruiser texture\n";
    }
    if (!destroyerTexture.loadFromFile("images/D.png"))
    {
        std::cout << "Error loading destroyer texture\n";
    }
    if (!submarineTexture.loadFromFile("images/S.png"))
    {
        std::cout << "Error loading submarine texture\n";
    }

    // declaring the player 1 ships sprites
    sf::Sprite p_1_A;
    sf::Sprite p_1_B;
    sf::Sprite p_1_C;
    sf::Sprite p_1_D;
    sf::Sprite p_1_S;

    //adding texture to player 1 ships sprites
    p_1_A.setTexture(aircraftCarrierTexture);
    p_1_B.setTexture(battleshipTexture);
    p_1_C.setTexture(cruiserTexture);
    p_1_D.setTexture(destroyerTexture);
    p_1_S.setTexture(submarineTexture);
    
    /* setting the position of the player 1 ships
    if they are vertical as the ships images are vertical*/
    p_1_A.setPosition(p_1_aircraftCarrier.col * cell_width + p1_x_offset, p_1_aircraftCarrier.row * cell_width + p1_y_offset);
    p_1_B.setPosition(p_1_battleship.col * cell_width + p1_x_offset, p_1_battleship.row * cell_width + p1_y_offset);
    p_1_C.setPosition(p_1_cruiser.col * cell_width + p1_x_offset, p_1_cruiser.row * cell_width + p1_y_offset);
    p_1_D.setPosition(p_1_destroyer.col * cell_width + p1_x_offset, p_1_destroyer.row * cell_width + p1_y_offset);
    p_1_S.setPosition(p_1_submarine.col * cell_width + p1_x_offset, p_1_submarine.row * cell_width + p1_y_offset);

    // if the ships are horizontal, rotate them
    if (p_1_aircraftCarrier.orientation == 'H')
    {
        p_1_A.setPosition(p_1_aircraftCarrier.col * cell_width + p1_x_offset, p_1_aircraftCarrier.row * cell_width + p1_y_offset + 80);
        p_1_A.setRotation(-90);
    }
    if (p_1_battleship.orientation == 'H')
    {
        p_1_B.setPosition(p_1_battleship.col * cell_width + p1_x_offset, p_1_battleship.row * cell_width + p1_y_offset + 80);
        p_1_B.setRotation(-90);
    }
    if (p_1_cruiser.orientation == 'H')
    {
        p_1_C.setPosition(p_1_cruiser.col * cell_width + p1_x_offset, p_1_cruiser.row * cell_width + p1_y_offset + 80);
        p_1_C.setRotation(-90);
    }
    if (p_1_destroyer.orientation == 'H')
    {
        p_1_D.setPosition(p_1_destroyer.col * cell_width + p1_x_offset, p_1_destroyer.row * cell_width + p1_y_offset + 80);
        p_1_D.setRotation(-90);
    }
    if (p_1_submarine.orientation == 'H')
    {
        p_1_S.setPosition(p_1_submarine.col * cell_width + p1_x_offset, p_1_submarine.row * cell_width + p1_y_offset + 80);
        p_1_S.setRotation(-90);
    }

    // declaring the player 2 ships sprites
    sf::Sprite p_2_A;
    sf::Sprite p_2_B;
    sf::Sprite p_2_C;
    sf::Sprite p_2_D;
    sf::Sprite p_2_S;

    //adding texture to player 2 ships sprites
    p_2_A.setTexture(aircraftCarrierTexture);
    p_2_B.setTexture(battleshipTexture);
    p_2_C.setTexture(cruiserTexture);
    p_2_D.setTexture(destroyerTexture);
    p_2_S.setTexture(submarineTexture);

    /* setting the position of the player 2 ships
    if they are vertical as the ships images are vertical*/
    p_2_A.setPosition(p_2_aircraftCarrier.col * cell_width + p2_x_offset, p_2_aircraftCarrier.row * cell_width + p2_y_offset);
    p_2_B.setPosition(p_2_battleship.col * cell_width + p2_x_offset, p_2_battleship.row * cell_width + p2_y_offset);
    p_2_C.setPosition(p_2_cruiser.col * cell_width + p2_x_offset, p_2_cruiser.row * cell_width + p2_y_offset);
    p_2_D.setPosition(p_2_destroyer.col * cell_width + p2_x_offset, p_2_destroyer.row * cell_width + p2_y_offset);
    p_2_S.setPosition(p_2_submarine.col * cell_width + p2_x_offset, p_2_submarine.row * cell_width + p2_y_offset);

    // if the ships are horizontal, rotate them
    if (p_2_aircraftCarrier.orientation == 'H')
    {
        p_2_A.setPosition(p_2_aircraftCarrier.col * cell_width + p2_x_offset, p_2_aircraftCarrier.row * cell_width + p2_y_offset + 80);
        p_2_A.setRotation(-90);
    }
    if (p_2_battleship.orientation == 'H')
    {
        p_2_B.setPosition(p_2_battleship.col * cell_width + p2_x_offset, p_2_battleship.row * cell_width + p2_y_offset + 80);
        p_2_B.setRotation(-90);
    }
    if (p_2_cruiser.orientation == 'H')
    {
        p_2_C.setPosition(p_2_cruiser.col * cell_width + p2_x_offset, p_2_cruiser.row * cell_width + p2_y_offset + 80);
        p_2_C.setRotation(-90);
    }
    if (p_2_destroyer.orientation == 'H')
    {
        p_2_D.setPosition(p_2_destroyer.col * cell_width + p2_x_offset, p_2_destroyer.row * cell_width + p2_y_offset + 80);
        p_2_D.setRotation(-90);
    }
    if (p_2_submarine.orientation == 'H')
    {
        p_2_S.setPosition(p_2_submarine.col * cell_width + p2_x_offset, p_2_submarine.row * cell_width + p2_y_offset + 80);
        p_2_S.setRotation(-90);
    }


////////////////////////////////////////////////////////////////////////

    w.setFramerateLimit(60);

    //boolean variables to switch between players
    bool isGameOver = false;
    bool isPlayer1 = true;
    bool isPlayer2 = false;

    //variables to store the row and column of the cell that was attacked
    int attacked_row = 0;
    int attacked_col = 0;


    // Game loop
    while (w.isOpen())
    {
        sf::Event mouseEvent;
        while (w.pollEvent(mouseEvent))
        {
            if (mouseEvent.type == sf::Event::Closed)
            {
                w.close();
            }
            if (mouseEvent.type == sf::Event::MouseButtonPressed)
            {
                if (isPlayer1 && mouseEvent.mouseButton.x > p2_x_offset && mouseEvent.mouseButton.x < p2_x_offset + grid_size * cell_width)
                {
                    if (mouseEvent.mouseButton.y > p2_y_offset && mouseEvent.mouseButton.y < p2_y_offset + grid_size * cell_width)
                    {
                        processClick(mouseEvent.mouseButton.x, mouseEvent.mouseButton.y, attacked_row, attacked_col, cell_width, p2_x_offset, p2_y_offset, player2Grid);
                        if (isSwitchPlayer(isPlayer1, isPlayer2, player2Grid, attacked_row, attacked_col))
                        {
                            trackTargetedShipHealth(p_2_aircraftCarrier.spaces, p_2_battleship.spaces, p_2_cruiser.spaces, p_2_destroyer.spaces, p_2_submarine.spaces, attacked_row, attacked_col, player2Grid);
                            saveAttackInGrid(player2Grid, attacked_row, attacked_col, shoot_sound, splash_sound, explosion_sound);                            
                                    w.clear();
                                    w.draw(background);
                                    // Draw player1's grid
                                    drawGridLines(w, p1_x_offset, p1_y_offset, grid_size, cell_width);
                                    // Draw player2's grid
                                    drawGridLines(w, p2_x_offset, p2_y_offset, grid_size, cell_width);
                                    //draw rectangles for hit and miss
                                    drawRectangles(w, p1_x_offset, p1_y_offset, grid_size, cell_width, player1Grid);
                                    drawRectangles(w, p2_x_offset, p2_y_offset, grid_size, cell_width, player2Grid);
                                    // Draw the ships if they are destroyed completely
                                    if (!p_1_aircraftCarrier.spaces)
                                        w.draw(p_1_A);
                                    if (!p_1_battleship.spaces)
                                        w.draw(p_1_B);
                                    if (!p_1_cruiser.spaces)
                                        w.draw(p_1_C);
                                    if (!p_1_destroyer.spaces)
                                        w.draw(p_1_D);
                                    if (!p_1_submarine.spaces)
                                        w.draw(p_1_S);
                                    if (!p_2_aircraftCarrier.spaces)
                                        w.draw(p_2_A);
                                    if (!p_2_battleship.spaces)
                                        w.draw(p_2_B);
                                    if (!p_2_cruiser.spaces)
                                        w.draw(p_2_C);
                                    if (!p_2_destroyer.spaces)
                                        w.draw(p_2_D);
                                    if (!p_2_submarine.spaces)
                                        w.draw(p_2_S);
                                    w.display();
                            sf::sleep(sf::milliseconds(500));

                            player1Moves--;
                            player2Health = p_2_aircraftCarrier.spaces + p_2_battleship.spaces + p_2_cruiser.spaces + p_2_destroyer.spaces + p_2_submarine.spaces;
                            if (!player2Health)
                            {
                                saveScoreInFile(player1Moves, player1Name);
                                cout << player1Name << " wins" << endl;
                                isGameOver = true;        
                            }
                        }
                    }
                }
                else if (gameMode == "player_vs_player" && isPlayer2)
                {
                    if (mouseEvent.mouseButton.x > p1_x_offset && mouseEvent.mouseButton.x < p1_x_offset + grid_size * cell_width)
                    {
                        if (mouseEvent.mouseButton.y > p1_y_offset && mouseEvent.mouseButton.y < p1_y_offset + grid_size * cell_width)
                        {
                            processClick(mouseEvent.mouseButton.x, mouseEvent.mouseButton.y, attacked_row, attacked_col, cell_width, p1_x_offset, p1_y_offset, player1Grid);
                            if (isSwitchPlayer(isPlayer1, isPlayer2, player1Grid, attacked_row, attacked_col))
                            {
                                trackTargetedShipHealth(p_1_aircraftCarrier.spaces, p_1_battleship.spaces, p_1_cruiser.spaces, p_1_destroyer.spaces, p_1_submarine.spaces, attacked_row, attacked_col, player1Grid);
                                saveAttackInGrid(player1Grid, attacked_row, attacked_col, shoot_sound, splash_sound, explosion_sound);
                                drawRectangles(w, p1_x_offset, p1_y_offset, grid_size, cell_width, player1Grid);
                                player2Moves--;
                                player1Health = p_1_aircraftCarrier.spaces + p_1_battleship.spaces + p_1_cruiser.spaces + p_1_destroyer.spaces + p_1_submarine.spaces;
                                if (!player1Health)
                                {
                                    saveScoreInFile(player2Moves, player2Name);
                                    cout << player2Name << " wins" << endl;
                                    isGameOver = true;
                                }
                            }
                        }
                    }
                
                }
            }
        }

        if (gameMode == "player_vs_computer" && isPlayer2)
        {
            computerAttack(player1Grid, p_1_aircraftCarrier.spaces, p_1_battleship.spaces, p_1_cruiser.spaces, p_1_destroyer.spaces, p_1_submarine.spaces, shoot_sound, splash_sound, explosion_sound);
            player2Moves--;

            // change the player and update the health of the player
            bool temp = isPlayer1;
            isPlayer1 = isPlayer2;  
            isPlayer2 = temp;
            player1Health = p_1_aircraftCarrier.spaces + p_1_battleship.spaces + p_1_cruiser.spaces + p_1_destroyer.spaces + p_1_submarine.spaces;
            
            if (!player1Health)
            {
                saveScoreInFile(player2Moves, "computer");
                cout << "Computer wins" << endl;
                isGameOver = true;
            }
        }

        
        if (isGameOver)
        {
            // Display the leaderboard if the game is over
            leaderboard(w);
            return 0;
        }

        w.clear();
        w.draw(background);

        // Draw player1's grid
        drawGridLines(w, p1_x_offset, p1_y_offset, grid_size, cell_width);

        // Draw player2's grid
        drawGridLines(w, p2_x_offset, p2_y_offset, grid_size, cell_width);

        //draw rectangles for hit and miss
        drawRectangles(w, p1_x_offset, p1_y_offset, grid_size, cell_width, player1Grid);
        drawRectangles(w, p2_x_offset, p2_y_offset, grid_size, cell_width, player2Grid);

        // Draw the ships if they are destroyed completely
        if (!p_1_aircraftCarrier.spaces)
            w.draw(p_1_A);
        if (!p_1_battleship.spaces)
            w.draw(p_1_B);
        if (!p_1_cruiser.spaces)
            w.draw(p_1_C);
        if (!p_1_destroyer.spaces)
            w.draw(p_1_D);
        if (!p_1_submarine.spaces)
            w.draw(p_1_S);

        if (!p_2_aircraftCarrier.spaces)
            w.draw(p_2_A);
        if (!p_2_battleship.spaces)
            w.draw(p_2_B);
        if (!p_2_cruiser.spaces)
            w.draw(p_2_C);
        if (!p_2_destroyer.spaces)
            w.draw(p_2_D);
        if (!p_2_submarine.spaces)
            w.draw(p_2_S);

        w.display();
    }
}